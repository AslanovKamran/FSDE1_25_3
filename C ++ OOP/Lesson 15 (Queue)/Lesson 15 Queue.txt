📚 Queue 

Сегодня рассмотрим тип коллекции под названием очередь. Если стек работает по принципу LIFO, то очередь работает по принципу FIFO - first in first out. 

Данную коллекцию можно представить как самую обычную очередь на кассе - человека, который пришел первым обслужат первым и он выйдет из очереди раньше всех.

Говоря на языке кода - мы добавляем элементы в конец, а читаем с начала массива. По факту это тот же самый стек только чуть измененный. Для этого я скопирую реализацию стека и сделаю в ней изменения:

class Stack
    {
    private:

        const int capacity;                 // Максимальное количество элементов
        int* arr = new int [capacity];      // Массив фиксированной длины
        int nextAvailablePosition = 0;      // Указывает на следующую свободную ячейку

    public:

        Stack (int _capacity) : capacity(_capacity){}

        void push(int data)
        {
            if (nextAvailablePosition >= capacity)
            {
                cout << "Stack overflow!" << endl;
                return;
            }

            arr[nextAvailablePosition] = data;
            nextAvailablePosition++;
        }

        int pop()
        {
            if (nextAvailablePosition == 0)
            {
                cout << "Stack is empty!" << endl;
                return -1; 
            }

            nextAvailablePosition--;
            return arr[nextAvailablePosition];
        }

        int peek()
        {
            if (nextAvailablePosition == 0)
            {
                cout << "Stack is empty!" << endl;
                return -1;
            }

            return arr[nextAvailablePosition - 1];
        }

        bool isEmpty()
        {
            return nextAvailablePosition == 0;
        }

        void print()
        {
            if (isEmpty())
            {
                cout << "Stack is empty!" << endl;
                return;
            }

            cout << "Stack content: ";
            for (int i = 0; i < nextAvailablePosition; i++)
            {
                cout << arr[i] << " ";
            }
            cout << endl;
        }
    };


Во первых нужно разобраться то как работают добавление и удаление элемента из очереди. Представим, что у нас уже есть очередь вида:

Start -> 11, 22, 33, 44, 55 <- End

✅ При добавлении нового элемента он встает в конец массива. Тут все ОК. Ни строчки кода я здесь не поменяю.

📌 Что же делать для "удаления" элемента из очереди. 
Как и было сказано элементы из очереди выходят из начала. Так как самым первым я "пушнул" элемент 11, то при pop он же и должен выйти первым. Теперь подумаем как мы будем его удалять. Нам нужно сделать так чтобы наш nextAvailablePosition уменьшился на единицу, но если я просто сделаю так, то я потеряю 55, а не 11. Значит нужно сделать так, чтобы 11 и 55 поменялись местами, а точнее мне нужно сделать по элементное смещение, чтобы 11 поменялся с 22, потом с 33 и так далее до 55ти.

Для этого нужно немного подправить уже существующий метод:

    int pop()
    {
        int firstElementInQueue = arr[0];

        for (int i = 0; i < nextAvailablePosition - 1; i ++)
        {
            arr[i] = arr[i + 1];
        }
        nextAvailablePosition--;

        return firstElementInQueue;
    }

Тоже самое касается и метода peek. В стеке он смотрел на самый верхний (последний элемент) элемент в массиве. В очереди же все наоборот, он должен выдавать мне самый первый элемент который в эту очередь зашел.

    int peek()
    {
        return arr[0];
    }

Все остальные методы остаются без изменений, единственное, что нужно поменять это имя класса и конструктора соответсвенно.

🧠 Теперь осталось лишь доработать наш класс полностью с проверками, деструктором и правильным выводом данных.


    class Queue
    {
    private:
        const int capacity;
        int* arr;
        int nextAvailablePosition = 0;

    public:
        
        Queue(int _capacity) : capacity(_capacity)
        {
            arr = new int[capacity];
        }

        ~Queue()
        {
            delete[] arr;
        }

        void push(int data)
        {
            if (nextAvailablePosition >= capacity)
            {
                cout << "Queue overflow!" << endl;
                return;
            }

            arr[nextAvailablePosition] = data;
            nextAvailablePosition++;
        }

        int pop()
        {
            if (isEmpty())
            {
                cout << "Queue is empty!" << endl;
                return -1;
            }

            int first = arr[0];

            for (int i = 0; i < nextAvailablePosition - 1; i++)
            {
                arr[i] = arr[i + 1];
            }

            nextAvailablePosition--;
            return first;
        }

        int peek()
        {
            if (isEmpty())
            {
                cout << "Queue is empty!" << endl;
                return -1;
            }

            return arr[0];
        }

        bool isEmpty()
        {
            return nextAvailablePosition == 0;
        }

        void print()
        {
            if (isEmpty())
            {
                cout << "Queue is empty!" << endl;
                return;
            }

            cout << "Queue content: ";
            for (int i = 0; i < nextAvailablePosition; i++)
            {
                cout << arr[i] << " ";
            }
            cout << endl;
        }
    };

    int main ()
    {
        Queue st = Queue(10);
        st.push(10);
        st.push(20);
        st.push(30);
        
        st.pop();
        
        cout<<st.peek();
    }


📌 Итог: Очередь (queue) — это одна из самых применимых структур данных в реальной жизни. Она идеально подходит для упорядоченной обработки элементов, где важен порядок поступления: кто первый пришёл — тот первый и обслуживается (FIFO — First In, First Out).

Во многих приложениях (веб-серверах, играх, операционных системах) есть очередь задач, которые нужно выполнить.

Пример:

    Сервер получает 1000 запросов от пользователей. Они ставятся в очередь и обрабатываются по мере поступления.

    В операционной системе: процессы, ожидающие выполнение, находятся в очереди задач процессора.

    Когда ты отправляешь несколько документов на принтер, они попадают в очередь печати.

    Во многих играх используются очереди для обработки команд пользователя по очереди

    Например, при потоковой передаче видео (YouTube) пакеты попадают в буфер — это тоже очередь.


📋 Практика:

Описание задачи:

В небольшом кафе работает автоматическая система обработки заказов. Каждый заказ добавляется в очередь, и повар берёт их в порядке поступления (FIFO).

Ваша задача — реализовать класс OrderQueue, который будет:

• Добавлять новые заказы
• Показывать следующий заказ
• Удалять (обрабатывать) заказы
• Показывать список ожидающих заказов


🧑‍🎓 Что должен уметь класс OrderQueue:

| Метод                             | Описание                                                            |
| --------------------------------- | ------------------------------------------------------------------- |
| `void addOrder(string orderName)` | Добавляет заказ в очередь                                           |
| `string nextOrder()`              | Возвращает имя следующего заказа (без удаления)                     |
| `string processOrder()`           | Удаляет и возвращает следующий заказ (как будто он был приготовлен) |
| `bool isEmpty()`                  | Проверяет, пуста ли очередь                                         |
| `void showOrders()`               | Выводит все текущие заказы в очереди                                |



📌 Условия:

• Максимальная длина очереди: 10 заказов
• Если очередь полная — нельзя добавить новый заказ
• Если очередь пустая — нельзя обработать или посмотреть заказ

💡 Пример Работы программы

Добро пожаловать в систему кафе!

1. Добавить заказ
2. Посмотреть следующий заказ
3. Приготовить заказ
4. Показать очередь заказов
5. Выход    

> 1
Введите название заказа: Латте

> 1
Введите название заказа: Капучино

> 2
Следующий заказ: Латте

> 3
Заказ "Латте" приготовлен!

> 4
Текущие заказы: Капучино


🏆 Доп задание 

Добавить пункт cancelOrderByIndex(int index)