📚 Стек (Stack) в C++

🔁 Напоминание про связные списки

На прошлом уроке мы рассмотрели односвязный список.
Он называется так, потому что у каждого узла есть только один указатель — на следующий элемент.

Существуют разновидности списков:

1. Doubly Linked List (двусвязный список) — каждый узел хранит два указателя:
на следующий (next) и предыдущий (previous) элементы.
У первого элемента head → previous = nullptr,
у последнего — tail → next = nullptr.

2. Cycled Doubly Linked List (зацикленный двусвязный список) —
хвост списка указывает на голову, а голова — на хвост.
Таким образом список образует кольцо.

 
🧠 Что такое стек?

Теперь давайте рассмотрим структуру данных под названием stack (стек). С этой структурой вы на самом деле сталкиваетесь постоянно.

Например:

    В контексте памяти: все локальные переменные во время выполнения программы помещаются в стек и удаляются из него по завершении работы.

    Если вы переполните отведённую область памяти, получите ошибку stack overflow.

👉 Что такое стек — это коллекция, которая работает по принципу LIFO — Last In, First Out (последним пришёл — первым ушёл).

Визуально это можно представить как стопку тарелок, размещённых одна на другой. Чтобы достать самую первую тарелку (внизу), сначала нужно убрать все, что лежат выше. То есть:

    Last In — последний добавленный элемент

    First Out — первым удаляется


💡 Где используется стек?

📞 Рекурсивные вызовы:
    Каждый вызов функции помещается в стек, и после выполнения возвращается назад по цепочке.

↩️ Команда “Отменить” (Ctrl + Z):
    Программа хранит историю действий в стеке и откатывается на предыдущий шаг.

🌐 Браузер “Назад”:
    При нажатии кнопки “Назад” вы возвращаетесь к предыдущей странице.


🧠 Особенности стека
По своей сути стек можно считать ограниченным массивом. У него нет методов вроде insert(), getAt() и других, работающих с произвольными индексами.

У стека всего одна точка входа — вершина (top).
Все операции выполняются только через неё.


🧑‍💻 Базовые методы стека

Во всех языках программирования для работы со стеком используется небольшой и стандартный набор методов.


🟢 push()   Добавить элемент    Кладёт новый элемент сверху                  
🟠 pop()    Удалить элемент     Удаляет верхний элемент и возвращает его      
🔵 peek()   Посмотреть элемент  Возвращает верхний элемент, не удаляя его 



🧠 В чём разница между peek() и pop()?


| Характеристика            | `peek()` — посмотреть                         | `pop()` — извлечь и удалить                      |
| ------------------------- | --------------------------------------------- | ------------------------------------------------ |
| **Что делает**            | Возвращает верхний элемент, **не удаляя его** | Возвращает и **удаляет верхний элемент**         |
| **Изменяет стек?**        | ❌ Нет                                        | ✅ Да                                             |
| **Когда использовать**    | Когда нужно просто узнать, что наверху        | Когда нужно обработать и удалить верхний элемент |
| **Возвращаемое значение** | Значение на вершине                           | Значение на вершине                              |



✅ Краткое резюме

    peek() = посмотреть 👀 
    pop() = взять и убрать 🗑️ 
    Оба метода возвращают значение с вершины, но только pop() изменяет стек.


🧑‍💻 Теперь обладая всеми нашими знаниями попробуем создать стек.

    class Stack
    {
    private:

        const int capacity = 10;            // Максимальное количество элементов
        int arr[10];                        // Массив фиксированной длины
        int currentTop = 0;      // Указывает на следующую свободную ячейку

    public:
        // Добавить элемент в стек
        void push(int data)
        {
            if (currentTop >= capacity)
            {
                cout << "Stack overflow!" << endl;
                return;
            }

            arr[currentTop] = data;
            currentTop++;
        }

        // Удалить и вернуть последний элемент
        int pop()
        {
            if (currentTop == 0)
            {
                cout << "Stack is empty!" << endl;
                return -1; 
            }

            currentTop--;
            return arr[currentTop];
        }

        // Посмотреть последний элемент (без удаления)
        int peek()
        {
            if (currentTop == 0)
            {
                cout << "Stack is empty!" << endl;
                return -1;
            }

            return arr[currentTop - 1];
        }

        // Проверка на пустоту
        bool isEmpty()
        {
            return currentTop == 0;
        }

        // Вывод содержимого стека
        void print()
        {
            if (isEmpty())
            {
                cout << "Stack is empty!" << endl;
                return;
            }

            cout << "Stack content: ";
            for (int i = 0; i < currentTop; i++)
            {
                cout << arr[i] << " ";
            }
            cout << endl;
        }
    };



👀 В чем минус нашего текущего подхода. Наш стек расчитан только на 10 элементов. И это значение константное. Даже если я вынесу capacity за пределы private области изменить ее значание я никак не смогу. И это логично, так как я должен сказать ОС сколько байт памяти мне нужно (в данном случае 10*4 = 40). А что если я хочу задавать размер стека сам, не ограничиваясь 10тью элементами, но в то же время хочу, чтобы данные размер не мог быть изменен далее. Наших текущих знаний для этого не достаточно. Все что я могу придумать это:

    class Stack
    {
    private:
        const int capacity;            
        int* arr = new int[capacity];  
        int currentTop = 0;            

    public:
        
        Stack(int _capacity)
        {
            capacity = _capacity;
        }
        
        //Other methods
    };
 
Компилятор не позволит мне сделать такую операцию и выдаст ошибку uninitialized const member in ‘const int’. Однако существует такое понятие как список инициализации. В основном он применяется как раз таки для таких случаев, когда нам нужно присвоить константное значение вне цикла.

📌 Что такое initialization list:

В C++ конструктор класса может инициализировать члены класса двумя способами:

    Присваиванием в теле конструктора
    С помощью списка инициализации — это запись после двоеточия : перед телом конструктора.

Он необходим для инициализации константных переменных (const). Инициализация через список происходит раньше, чем выполнение тела конструктора.

    Stack(int _capacity) : capacity(_capacity)
    {

    }

💡 Что здесь произошло:

В списке инициализации : capacity(_сapacity) происходит прямая инициализация всех трёх переменных. Данный подход является самым быстрым подходом создания объектов. Тут по факту происходит прямая инициализация полей перед непосредственным срабатыванием конструктора. Однако в угоду скорости мы жертвуем безопасностью, ведь в таком подходе я никак не смогу валидировать значение _capacity перед присваиванием. Однако стоить отметить, что для валидации зачастую используются сторонние ф-ции или целые сервисы.

Как теперь использовать мой стек. Так как я создал перегруженный конструктор, то просто так создать теперь стек без указания размера я не смогу.

    Stack st = Stack(10);
    st.push(10);
    st.push(20);
    st.push(30);

Теперь благодаря списку инициализации я могу указывать размер стека прямо в main. Но в дальнейшем я его никак не изменю.


🧠 Стек в действии: рекурсия
Все рекурсивные алгоритмы также работают на принципе стека. Давайте рассмотрим рекурсивный алгоритм высчитывания факториала. Вот как выглядит код:

    int factorial(int number)
    {
        if(number == 0)
            return 1;
        
        return number * factorial(number - 1);
    }

🔍 Пошаговое выполнение
Теперь давайте подробно рассмотрим, что происходит в коде. Допустим я вызываю данную ф-цию и передаю туда число 5.

    int main()
    {
        int result = factorial(5);
        cout << result;
    }

На каждом шаге в стек добавляется новый вызов:

    factorial(5)
     ↓
    factorial(4)
     ↓
    factorial(3)
     ↓
    factorial(2)
     ↓
    factorial(1)
     ↓
    factorial(0)


    
Когда выполняется factorial(0), стек достигает базового условия.
Теперь он начинает “сворачиваться”, возвращая значения обратно:

    factorial(0) → 1
    factorial(1) → 1 * 1
    factorial(2) → 2 * 1
    factorial(3) → 3 * 2
    factorial(4) → 4 * 6
    factorial(5) → 5 * 24 = 120

✅ Итоги

    Стек — это структура LIFO (Last In, First Out).
    Все операции (push, pop, peek) происходят с вершины.

Рекурсия, Undo, кнопка “Назад” — всё это примеры работы стека.


🎯 Разворот строки с помощью стека.
Дана строка, например: "Hello"
Нужно получить строку в обратном порядке: "olleH"

🧱 Пример “на пальцах”

Исходная строка: "ABC"

Шаг 1: push символы в стек:
  A → push
  B → push
  C → push

Стек (снизу вверх): A, B, C

Шаг 2: pop все элементы:
  pop → C
  pop → B
  pop → A

Результат: "CBA"









    #include <iostream>
    #include <array>
    #include <string>
    using namespace std;

    class Stack
    {
    private:
        static const int capacity = 100;       // фиксированный размер
        array<char, capacity> arr;             // безопасный встроенный массив
        int currentTop = 0;                    // индекс следующей свободной позиции

    public:
        // Проверка, пуст ли стек
        bool isEmpty() const
        {
            return currentTop == 0;
        }

        // Проверка, полон ли стек
        bool isFull() const
        {
            return currentTop == capacity;
        }

        // Добавить элемент
        void push(char value)
        {
            if (isFull())
            {
                cout << "Stack overflow! Cannot push more elements.\n";
                return;
            }

            arr[currentTop++] = value;
        }

        // Удалить элемент
        char pop()
        {
            if (isEmpty())
            {
                cout << "Stack underflow! Nothing to pop.\n";
                return '\0';
            }

            return arr[--currentTop];
        }

        // Посмотреть верхний элемент
        char top() const
        {
            if (isEmpty())
            {
                cout << "Stack is empty!\n";
                return '\0';
            }

            return arr[currentTop - 1];
        }
    };



    string reverseString(const string& input)
    {
        Stack st;

        for (char c : input)
            st.push(c);

        string reversed;
        while (!st.isEmpty())
            reversed += st.pop();

        return reversed;
    }


    int main()
    {
        string word = "Stack";
        string result = reverseString(word);

        cout << "Original: " << word << endl;
        cout << "Reversed: " << result << endl;

        return 0;
    }