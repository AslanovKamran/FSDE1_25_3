📚 Напоминание про связные списки

На прошлом уроке мы с вами рассмотрели такой тип коллекции, как односвязный список. Он называется так, потому что у каждого узла есть всего лишь один указатель — на следующий элемент. Существуют разновидности этих списков, о которых стоит знать:

1. Doubly Linked List — разновидность списка, где каждый узел хранит в себе два указателя: на следующий и на предыдущий узлы. Указатели обычно называют next и previous. Очевидно, что у head → previous = nullptr, а у tail → next = nullptr.

2. Cycled Doubly Linked List — разновидность двусвязного списка, в котором появляется зацикливание. Вместо nullptr, голова списка указывает на хвост, а хвост — на голову. Таким образом список превращается в кольцо.


🧠 Что такое стек?

Теперь давайте рассмотрим структуру данных под названием stack (стек). С этой структурой вы на самом деле сталкиваетесь постоянно.

Например:

    В контексте памяти: все локальные переменные во время выполнения программы помещаются в стек и удаляются из него по завершении работы.

    Если вы переполните отведённую область памяти, получите ошибку stack overflow.

👉 Что такое стек — это коллекция, которая работает по принципу LIFO — Last In, First Out (последним пришёл — первым ушёл).

Визуально это можно представить как стопку тарелок, размещённых одна на другой. Чтобы достать самую первую тарелку (внизу), сначала нужно убрать все, что лежат выше. То есть:

    Last In — последний добавленный элемент

    First Out — первым удаляется


💡 Где в жизни используется стек?

    Работу стека можно отследить в разных местах:

    При вызове рекурсивных функций — каждый вызов помещается в стек, и после выполнения возвращается назад по цепочке.

    При нажатии Ctrl + Z (Undo) — вы откатываетесь на предыдущие действия.

В браузере при клике по кнопке “Назад” — переходите к предыдущей странице.

🧠 Особенности стека
По своей сути стек можно считать ограниченным массивом. У него нет методов вроде insert(), getAt() и других, работающих с произвольными индексами.

У стека есть одна точка входа — верхушка стека.


👉 Все операции добавления и удаления происходят только с этой верхушки:

    Добавляем элемент — кладём сверху.
    Удаляем элемент — снимаем верхний.


🧑‍💻 Базовые методы стека

Во всех языках программирования для работы со стеком используется небольшой и стандартный набор методов. Эти методы называются одинаково:

    push - добавить элемент
    pop - удалить самый последний элемент и вернуть его
    peek - посмотреть на самый последний элемент (без удаления).


🧠 В чём разница между peek() и pop()?


| Характеристика            | `peek()` — посмотреть                         | `pop()` — извлечь и удалить                      |
| ------------------------- | --------------------------------------------- | ------------------------------------------------ |
| **Что делает**            | Возвращает верхний элемент, **не удаляя его** | Возвращает и **удаляет верхний элемент**         |
| **Изменяет стек?**        | ❌ Нет                                        | ✅ Да                                             |
| **Когда использовать**    | Когда нужно просто узнать, что наверху        | Когда нужно обработать и удалить верхний элемент |
| **Возвращаемое значение** | Значение на вершине                           | Значение на вершине                              |



✅ Краткое резюме

    peek() = посмотреть 👀 
    pop() = взять и убрать 🗑️ 
    Оба метода возвращают значение с вершины, но только pop() изменяет стек.


🧑‍💻 Теперь обладая всеми нашими знаниями попробуем создать стек.

    class Stack
    {
    private:

        const int capacity = 10;            // Максимальное количество элементов
        int arr[10];                        // Массив фиксированной длины
        int nextAvailablePosition = 0;      // Указывает на следующую свободную ячейку

    public:
        // Добавить элемент в стек
        void push(int data)
        {
            if (nextAvailablePosition >= capacity)
            {
                cout << "Stack overflow!" << endl;
                return;
            }

            arr[nextAvailablePosition] = data;
            nextAvailablePosition++;
        }

        // Удалить и вернуть последний элемент
        int pop()
        {
            if (nextAvailablePosition == 0)
            {
                cout << "Stack is empty!" << endl;
                return -1; 
            }

            nextAvailablePosition--;
            return arr[nextAvailablePosition];
        }

        // Посмотреть последний элемент (без удаления)
        int peek()
        {
            if (nextAvailablePosition == 0)
            {
                cout << "Stack is empty!" << endl;
                return -1;
            }

            return arr[nextAvailablePosition - 1];
        }

        // Проверка на пустоту
        bool isEmpty()
        {
            return nextAvailablePosition == 0;
        }

        // Вывод содержимого стека
        void print()
        {
            if (isEmpty())
            {
                cout << "Stack is empty!" << endl;
                return;
            }

            cout << "Stack content: ";
            for (int i = 0; i < nextAvailablePosition; i++)
            {
                cout << arr[i] << " ";
            }
            cout << endl;
        }
    };



👀 В чем минус нашего текущего подхода. Наш стек расчитан только на 10 элементов. И это значение константное. Даже если я вынесу capacity за пределы private области изменить ее значание я никак не смогу. И это логично, так как я должен сказать ОС сколько байт памяти мне нужно (в данном случае 10*4 = 40). А что если я хочу задавать размер стека сам, не ограничиваясь 10тью элементами, но в то же время хочу, чтобы данные размер не мог быть изменен далее. Наших текущих знаний для этого не достаточно. Все что я могу придумать это:

    class Stack
    {
    private:
        const int capacity;            
        int* arr = new int[capacity];  
        int currentTop = 0;            

    public:
        
        Stack(int _capacity)
        {
            capacity = _capacity;
        }
        
        //Other methods
    };
 
Компилятор не позволит мне сделать такую операцию и выдаст ошибку uninitialized const member in ‘const int’. Однако существует такое понятие как список инициализации. В основном он применяется как раз таки для таких случаев, когда нам нужно присвоить константное значение вне цикла.

📌 Что такое initialization list:

В C++ конструктор класса может инициализировать члены класса двумя способами:

    Присваиванием в теле конструктора
    С помощью списка инициализации — это запись после двоеточия : перед телом конструктора.

Он необходим для инициализации константных переменных (const). Инициализация через список происходит раньше, чем выполнение тела конструктора.

    Stack(int _capacity) : capacity(_capacity)
    {

    }

💡 Что здесь произошло:

В списке инициализации : capacity(_сapacity) происходит прямая инициализация всех трёх переменных. Данный подход является самым быстрым подходом создания объектов. Тут по факту происходит прямая инициализация полей перед непосредственным срабатыванием конструктора. Однако в угоду скорости мы жертвуем безопасностью, ведь в таком подходе я никак не смогу валидировать значение _capacity перед присваиванием. Однако стоить отметить, что для валидации зачастую используются сторонние ф-ции или целые сервисы.

Как теперь использовать мой стек. Так как я создал перегруженный конструктор, то просто так создать теперь стек без указания размера я не смогу.

    Stack st = Stack(10);
    st.push(10);
    st.push(20);
    st.push(30);

Теперь благодаря списку инициализации я могу указывать размер стека прямо в main. Но в дальнейшем я его никак не изменю.